---
title: "Centered algorithm with simulated data, external data set"
author: "Juan Li"
date: 2025-09-10
format: 
  html:
    toc: true
    html-math-method: katex
    css: styles.css
editor: visual
---

```{r}
#| warning: false
#| message: false
#| output: false

library(dplyr) # Data manipulation
library(ggplot2) # Data visualization
library(ggpubr) # ggarrange
library(fastDummies) # make dummy variables
library(rms)

source("R/util.R") 
# functions in "util.R"
# get_rcs: implement the formula of rcs components
# step_dummy: dummy variables
# step_rcs: rcs
# step_interaction: interaction terms
# step_center: centering
# get_mean: get mean values from the original dataset
# root.search: Root searching, not in use in this .qmd file

source("R/calibration.R") # for calibration plots
```

# Simulate data for this tutorial

For this tutorial, we will use a simulated dataset with the following predictors:

-   `x1`: a categorical/dichotomous variable with 2 categories: `cat1`, `cat2`

-   `x2`: a categorical variable with 3 categories: `cat1`, `cat2`, `cat3`

-   `x3`: a continuous variable with normal distribution, used as it is

-   `x4`: a continuous variablewith normal distribution, used with restricted cubic spline (rcs), `k_x4 = 4`

-   `x5`: a continuous variable with normal distribution, used as it is

-   `x6`: a continuous variablewith normal distribution, used with restricted cubic spline (rcs), `k_x6 = 3`

And we assume the outcome `y` is a linear combination of the predictors with some noise, and different kinds of interactions:

-   Interaction of two categorical variables: `x1`, `x2`

-   Interaction of one categorical variable and one continuous variabl (no rcs): `x2`, `x3`

-   Interaction of two continuous variables (no rcs): `x3`, `x5`

-   Interaction of one categorical variable and one continuous variabl (with rcs): `x2`, `x4`

-   Interaction of two continuous variables (one with rcs, one without): `x3`, `x4`

-   Interaction of two continuous variables (with rcs): `x4`, `x6`

We will create two data sets, the development data set as in "1.2 simulated_data_wt_interaction.qmd", and an external data set where distribution of each variable is different, while the relationship between the outcome `y` and predictors remains the same.


```{r}
# development data set
n <- 1000
seed <- 567

set.seed(seed)
data.dev <- data.frame(
  x1 = sample(
    c("cat1", "cat2"),
    size = n,
    replace = TRUE,
    prob = c(0.5, 0.5)
  ),
  x2 = sample(
    c("cat1", "cat2", "cat3"),
    size = n,
    replace = TRUE,
    prob = c(0.1, 0.4, 0.5)
  ),
  x3 = rnorm(n, mean = 100, sd = 38),
  x4 = rnorm(n, mean = 50, sd = 15),
  x5 = rnorm(n, mean = 30, sd = 5),
  x6 = rnorm(n, mean = 15, sd = 3),
  error = rnorm(n, mean = 0, sd = 3)
)

# -------- dummy variables --------
vars_cat <- c("x1", "x2")
data.dev <- step_dummy(data.dev, vars_cat)

# -------- rcs --------
# x4
k_x4 <- 4
rcs.fit <- rcs(data.dev$x4, k_x4)
knots_x4 <- attributes(rcs.fit)$parms # knot locations
# x6
k_x6 <- 3
rcs.fit <- rcs(data.dev$x6, k_x6)
knots_x6 <- attributes(rcs.fit)$parms # knot locations
# unpack rcs
vars_rcs <- c("x4", "x6")
knots_list <- list(knots_x4, knots_x6)
knots_list <- setNames(knots_list, vars_rcs)
data.dev <- step_rcs(data.dev, vars_rcs, knots_list)

# outcome
data.dev <- data.dev %>%
  mutate(x3_x5_interaction = x3 * x5) %>%
  mutate(
    y = case_when(
      x2 == "cat1" ~ 100 +
      3 * x1_cat2 +
      2 * x2_cat2 +
      0.5 * x2_cat3 +
      10 * x3 +
      25 * x4_rcs_1 +
      18 * x4_rcs_2 +
      21 * x4_rcs_3 -
      6 * x5 +
      0.6 * x6_rcs_1 +
      1.5 * x6_rcs_2 +
      0.1 * x3_x5_interaction +
      error,
    x2 == "cat2" ~ 100 +
      5 * x1_cat2 +    # change based on value of x2
      2 * x2_cat2 +
      0.5 * x2_cat3 +
      21 * x3 +        # change based on value of x2
      8 * x4_rcs_1 +  # change based on value of x2
      36 * x4_rcs_2 +  # change based on value of x2
      14 * x4_rcs_3 -  # change based on value of x2
      6 * x5 +
      0.6 * x6_rcs_1 +
      1.5 * x6_rcs_2 +
      0.1 * x3_x5_interaction +
      error,
    x2 == "cat3" ~ 100 +
      7 * x1_cat2 +    # change based on value of x2
      2 * x2_cat2 +
      0.5 * x2_cat3 +
      5 * x3 +         # change based on value of x2
      2.5 * x4_rcs_1 + # change based on value of x2
      40 * x4_rcs_2 +  # change based on value of x2
      16 * x4_rcs_3 -  # change based on value of x2
      6 * x5 +
      0.6 * x6_rcs_1 +
      1.5 * x6_rcs_2 +
      0.1 * x3_x5_interaction +
      error
  ))

# Only select the original predictors
data.dev <- data.dev %>% select(x1:x6, y)
```

```{r}
# external data set
n <- 500
seed <- 567

set.seed(seed)
data.val <- data.frame(
  x1 = sample(
    c("cat1", "cat2"),
    size = n,
    replace = TRUE,
    prob = c(0.3, 0.7)
  ),
  x2 = sample(
    c("cat1", "cat2", "cat3"),
    size = n,
    replace = TRUE,
    prob = c(0.4, 0.3, 0.3)
  ),
  x3 = rnorm(n, mean = 70, sd = 25),
  x4 = rnorm(n, mean = 60, sd = 12),
  x5 = rnorm(n, mean = 27, sd = 3.5),
  x6 = rnorm(n, mean = 20, sd = 5),
  error = rnorm(n, mean = 0, sd = 4)
)

# -------- dummy variables --------
vars_cat <- c("x1", "x2")
data.val <- step_dummy(data.val, vars_cat)

# -------- rcs --------
# x4
k_x4 <- 4
rcs.fit <- rcs(data.val$x4, k_x4)
knots_x4 <- attributes(rcs.fit)$parms # knot locations
# x6
k_x6 <- 3
rcs.fit <- rcs(data.val$x6, k_x6)
knots_x6 <- attributes(rcs.fit)$parms # knot locations
# unpack rcs
vars_rcs <- c("x4", "x6")
knots_list <- list(knots_x4, knots_x6)
knots_list <- setNames(knots_list, vars_rcs)
data.val <- step_rcs(data.val, vars_rcs, knots_list)

# outcome
data.val <- data.val %>%
  mutate(x3_x5_interaction = x3 * x5) %>%
  mutate(
    y = case_when(
      x2 == "cat1" ~ 100 +
      3 * x1_cat2 +
      2 * x2_cat2 +
      0.5 * x2_cat3 +
      10 * x3 +
      25 * x4_rcs_1 +
      18 * x4_rcs_2 +
      21 * x4_rcs_3 -
      6 * x5 +
      0.6 * x6_rcs_1 +
      1.5 * x6_rcs_2 +
      0.1 * x3_x5_interaction +
      error,
    x2 == "cat2" ~ 100 +
      5 * x1_cat2 +    # change based on value of x2
      2 * x2_cat2 +
      0.5 * x2_cat3 +
      21 * x3 +        # change based on value of x2
      8 * x4_rcs_1 +  # change based on value of x2
      36 * x4_rcs_2 +  # change based on value of x2
      14 * x4_rcs_3 -  # change based on value of x2
      6 * x5 +
      0.6 * x6_rcs_1 +
      1.5 * x6_rcs_2 +
      0.1 * x3_x5_interaction +
      error,
    x2 == "cat3" ~ 100 +
      7 * x1_cat2 +    # change based on value of x2
      2 * x2_cat2 +
      0.5 * x2_cat3 +
      5 * x3 +         # change based on value of x2
      2.5 * x4_rcs_1 + # change based on value of x2
      40 * x4_rcs_2 +  # change based on value of x2
      16 * x4_rcs_3 -  # change based on value of x2
      6 * x5 +
      0.6 * x6_rcs_1 +
      1.5 * x6_rcs_2 +
      0.1 * x3_x5_interaction +
      error
  ))

# Only select the original predictors
data.val <- data.val %>% select(x1:x6, y)
```

## Table 1 for the two datasets

```{r}
library(gtsummary)

data <- bind_rows(data.dev %>% mutate(type = "development"), 
                  data.val %>% mutate(type = "external"))

data %>% 
  tbl_summary(by = "type") %>% 
  modify_header(label = "**Variable**") %>% # update the column header
  modify_caption("Table 1. Summary of the two datasets") %>%
  bold_labels() %>% 
  as_flex_table()

data %>% 
  tbl_summary(by = "type",statistic = list(all_continuous() ~ "{mean} ({sd})")) %>% 
  modify_header(label = "**Variable**") %>% # update the column header
  modify_caption("Table 1. Summary of the two datasets") %>%
  bold_labels() %>% 
  as_flex_table()
```


# Original and centered model on the development dataset

```{r}
# The original model

options(scipen = 999)
# original model
fit.o <- lm(y ~ x1 + x2 + x3 + rcs(x4,k_x4) + x5 + rcs(x6,k_x6) + 
              x1*x2 + x2*x3 + x3*x5 + x2*rcs(x4,k_x4) + x3*rcs(x4,k_x4) + rcs(x4,k_x4)*rcs(x6,k_x6), data = data.dev)
```


```{r}
# Get the centered variables and terms

# -------- dummy variables --------
vars_cat <- c("x1", "x2")
data.dev <- step_dummy(data.dev, vars_cat)

# -------- rcs --------
# x4
k_x4 <- 4
rcs.fit <- rcs(data.dev$x4, k_x4)
knots_x4_dev <- attributes(rcs.fit)$parms # knot locations
# x6
k_x6 <- 3
rcs.fit <- rcs(data.dev$x6, k_x6)
knots_x6_dev <- attributes(rcs.fit)$parms # knot locations
# unpack rcs
vars_rcs <- c("x4", "x6")
knots_list <- list(knots_x4_dev, knots_x6_dev)
knots_list <- setNames(knots_list, vars_rcs)
data.dev <- step_rcs(data.dev, vars_rcs, knots_list)

# -------- interaction terms --------
interaction_list <- list(
  c("x1", "x2"),
  c("x2", "x3"),
  c("x3", "x5"),
  c("x2", "x4"),
  c("x3", "x4"),
  c("x4", "x6")
)
data.dev <- step_interaction(data.dev, interaction_list)

# -------- centering --------
vars_mean <- names(data.dev)
# get mean values
means.dev <- get_mean(data.dev, vars_mean)
# centering vars in the data.dev dataset
vars_center <- names(means.dev)
data.dev <- step_center(data.dev, vars_center, means.dev)
```


```{r}
# The centered model on the development dataset
paste0("Mean outcome in the dataset: ", mean(data.dev$y))
fit.c <- lm(y ~ x1_cat2_C + x2_cat2_C + x2_cat3_C + x3_C + x4_rcs_1_C + x4_rcs_2_C + x4_rcs_3_C + x5_C + x6_rcs_1_C + x6_rcs_2_C +
                # interaction terms of x1 * x2
                x1_cat2_by_x2_cat2_C + x1_cat2_by_x2_cat3_C +
                # interaction terms of x2 * x3
                x2_cat2_by_x3_C + x2_cat3_by_x3_C +
                # interaction terms of x3 * x5
                x3_by_x5_C +
                # interaction terms of x2 * rcs(x4, k_x4)
                x2_cat2_by_x4_rcs_1_C + 
                x2_cat3_by_x4_rcs_1_C + 
                x2_cat2_by_x4_rcs_2_C + 
                x2_cat3_by_x4_rcs_2_C + 
                x2_cat2_by_x4_rcs_3_C + 
                x2_cat3_by_x4_rcs_3_C +
                # interaction terms of x3 * rcs(x4, k_x4)
                x3_by_x4_rcs_1_C + x3_by_x4_rcs_2_C + x3_by_x4_rcs_3_C +
                # interaction terms of x4 * rcs(x6, k_x6)
                x4_rcs_1_by_x6_rcs_1_C +
                x4_rcs_2_by_x6_rcs_1_C +
                x4_rcs_3_by_x6_rcs_1_C +
                x4_rcs_1_by_x6_rcs_2_C +
                x4_rcs_2_by_x6_rcs_2_C +
                x4_rcs_3_by_x6_rcs_2_C, data = data.dev)

cbind(coef(fit.o), coef(fit.c))
```

Confirm that the original model and the centered model have the same predicted values.

```{r}
# The original model
data.dev$pred.o <- predict(fit.o, newdata = data.dev)

# The centered model 
data.dev$pred.c <- predict(fit.c, newdata = data.dev)

dfPlt <- data.frame(
  y = rep(data.dev$y,2),
  pred = c(data.dev$pred.o, data.dev$pred.c),
  type = c(rep("original", nrow(data.dev)), 
  rep("centered", nrow(data.dev)))
  )
dfPlt$type <- factor(dfPlt$type, levels = c("original", "centered"))
ggplot(dfPlt, aes(x = y, y = pred)) +
  geom_point(alpha=0.3) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  facet_wrap(~type)+
  theme_bw()

head(cbind(data.dev$y, data.dev$pred.o, data.dev$pred.c))
head(data.dev$pred.o - data.dev$pred.c)
```

# Transport the model to the external dataset

Two __VERY IMPORTANT__ notes:

- Using the knot locations from the DEVELOPMENT datasets.

- When re-centering in the external datasets using the new means, rememeber to update the intercept with the outcome mean in the EXTERNAL dataset.

Also, it's confirmed below that using the original model and the centered model with original means on the external dataset have the same predicted values.

```{r}

# Get the centered variables and terms

# -------- dummy variables --------
vars_cat <- c("x1", "x2")
data.val <- step_dummy(data.val, vars_cat)

# -------- rcs --------
# IMPORTANT: using knot locations from the DEVELOPMENT dataset, not the EXTERNAL dataset
# unpack rcs
vars_rcs <- c("x4", "x6")
knots_list <- list(knots_x4_dev, knots_x6_dev)
knots_list <- setNames(knots_list, vars_rcs)
data.val <- step_rcs(data.val, vars_rcs, knots_list)

# -------- interaction terms --------
interaction_list <- list(
  c("x1", "x2"),
  c("x2", "x3"),
  c("x3", "x5"),
  c("x2", "x4"),
  c("x3", "x4"),
  c("x4", "x6")
)
data.val <- step_interaction(data.val, interaction_list)

# -------- centering --------
vars_mean <- names(data.val)
# get mean values
means.val <- get_mean(data.val, vars_mean)
# centering vars in the data.val dataset
vars_center <- names(means.val)

# centering using the mean values in the DEVELOPMENR dataset
data.val.means.dev <- step_center(data.val, vars_center, means.dev)

# centering using the mean values in the EXTERNAL dataset
data.val.means.val <- step_center(data.val, vars_center, means.val)
```

```{r}
# The original model on the external dataset
data.val$pred <- predict(fit.o, newdata = data.val)

# The centered model on the external dataset, using the mean values in the DEVELOPMENT dataset
data.val.means.dev$pred <- predict(fit.c, newdata = data.val.means.dev)

# The centered model on the external dataset, using the mean values in the EXTERNAL dataset
# NOTE: need to manually changing the intercept to the new outconme mean
paste0("Mean outcome in the dataset: ", mean(data.val$y))
fit.c.2 <- fit.c
fit.c.2$coefficients[1] <- mean(data.val$y)
data.val.means.val$pred <- predict(fit.c.2, newdata = data.val.means.val)

dfPlt <- data.frame(
  y = rep(data.val$y,3),
  pred = c(data.val$pred, data.val.means.dev$pred, data.val.means.val$pred),
  type = c(rep("original", nrow(data.val)), 
  rep("centered: mean in development", nrow(data.val.means.dev)), 
  rep("centered: mean in external", nrow(data.val.means.val)))
  )
dfPlt$type <- factor(dfPlt$type, levels = c("original", "centered: mean in development", "centered: mean in external"))
ggplot(dfPlt, aes(x = y, y = pred)) +
  geom_point(alpha=0.3) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  facet_wrap(~type)+
  theme_bw()

head(cbind(data.val$y, data.val$pred, data.val.means.dev$pred, data.val.means.val$pred))
```

## Some calibration plots on the external dataset

```{r}
# ---------- Overall calibration ----------
# The original model 
res <- calibration(data.val$pred, data.val$y, labelPos.x = 1000, labelPos.y = 4500, marginPlt = TRUE)
res
```

```{r}
# The centered model with the original means 
# It is confirm that this is the same as using the original model. Will be ommitted below.
res <- calibration(data.val.means.dev$pred, data.val.means.dev$y, labelPos.x = 1000, labelPos.y = 4500, marginPlt = TRUE)
res
```

```{r}
# The centered model with the updated means
res <- calibration(data.val.means.val$pred, data.val.means.val$y, labelPos.x = 1000, labelPos.y = 4500, marginPlt = TRUE)
res
```

```{r}
# ---------- Calibration on x1 ----------
# The original model 
res <- calibration(data.val$pred, data.val$y, group = data.val$x1, labelPos.x = 1000, labelPos.y = 4500, marginPlt = TRUE)
res
```

```{r}
# The original model with the updated means
res <- calibration(data.val.means.val$pred, data.val.means.val$y, group = data.val.means.val$x1, labelPos.x = 1000, labelPos.y = 4500, marginPlt = TRUE)
res
```

```{r}
# ---------- Calibration on x4 category ----------
data.val <- data.val %>% mutate(x4_bin = factor(ntile(x4, n=3)))
levels(data.val$x4_bin) <- c("x4: low", "x4: medium", "x4: high")
data.val.means.dev <- data.val.means.dev %>% mutate(x4_bin = factor(ntile(x4, n=3)))
levels(data.val.means.dev$x4_bin) <- c("x4: low", "x4: medium", "x4: high")
data.val.means.val <- data.val.means.val %>% mutate(x4_bin = factor(ntile(x4, n=3)))
levels(data.val.means.val$x4_bin) <- c("x4: low", "x4: medium", "x4: high")

# The original model 
res <- calibration(data.val$pred, data.val$y, group = data.val$x4_bin, labelPos.x = 1000, labelPos.y = 4500, marginPlt = TRUE)
res
```

```{r}
# The original model with the updated means
res <- calibration(data.val.means.val$pred, data.val.means.val$y, group = data.val.means.val$x4_bin, labelPos.x = 1000, labelPos.y = 4500, marginPlt = TRUE)
res
```

```{r}

```